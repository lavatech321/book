

\begin{flushleft}
	
	\begin{itemize}
		\item \textbf{main()} serves as the entry point for a Java program. 
		\item When a Java program is executed, the JVM starts by looking for the main() method in the class specified in the command line arguments, and then executes the code inside it.
		\bigskip
		\syntaxblock{
			public static void main(String[] args)
		}
		\bigskip
		\item At runtime, JVM always searches for main method with the above prototype:
		\begin{itemize}
			\item \textbf{public:} To call main() from anywhere
			\item \textbf{static:} without existing object also, JVM has to call this method
			\item \textbf{void:} main() method wont return anything to JVM
			\item \textbf{main:} This is the name which is configured inside JVM
			\item \textbf{String[] args:} command line argument
		\end{itemize}
		\bigskip
		\noteblock{
			The main() syntax is very strict and if we perform any change then we will get runtime error from JVM saying “NoSuchMethodError: main”.
		}
		\bigskip
		\item Changes allowed in main():
		\begin{itemize}
			\item Order of modifier can be changed:
			\newline
			Eg: static public void main(String[] args)
			\item The command line argument’s string array can have different syntax:
			\newline
			Eg: public static void main(String args[])
			\item Identifier of the string array can change:
			\newline
			Eg: public static void main(String name[])
			\item String array can be taken as var\_arg parameter
			\newline
			Eg: public static void main(String… args)
			\item main() method can be declared with following modifiers:
			\begin{itemize}
				\item final
				\item synchroised
				\item strictfop
			\end{itemize}
			Eg:
			\codeblockfull{New.java}{
				class New \{ \\
				\s static final synchronized strictfp public void main(String... name)\{ \\
				\s \s System.out.println("Valid main method"); \\
				\s \} \\
				\} 
			}
		\end{itemize}
		\bigskip
		\item There can be multiple main() methods (i.e main() method over-loading is possible!). However JVm will always call String[] argument main method only.
		\bigskip
		\codeblockfull{New.java}{
			class New \{ \\
			\s	public static void main(String[] args)\{ \\
			\s	\s	System.out.println("Starting"); \\
			\s	\}
			\s	public static void main(int[] args)\{ \\
			\s \s		System.out.println("Sample 2"); \\
			\s	\}
			\}
		}
		\bigskip
		\outputblock{
			Starting
		}
		\newpage
		\item \textbf{Inheritance:} While executing child class, if child does not contain main(), then parent class main() will be executed.
		
		\codeblockfull{New.java}{
		class New \{ \\
		\s public static void main(String[] args)\{ \\
		\s \s System.out.println("Starting"); \\
		\s \} \\
		\} \\
		class C extends New \{\}
		}
		\bigskip
		\commandblock{
			\$ javac New.java  <- Creates C.class New.clas New.java  \\ 
			\$ java New \\ 
			Starting \\ 
			\$ java C \\
			Starting
		}
		\bigskip
		\item \textbf{Method hiding}: Child class can override parent class’s main(). This is not method overriding but it is method hiding.
		\newline
		Eg:
		\codeblockfull{New.java}{
			class New \{ \\
			\s	public static void main(String[] args)\{ \\
			\s \s		System.out.println("Starting New"); \\
			\s	\} \\
			\} \\
			class C extends New \{ \\
			\s	public static void main(String[] args)\{ \\
			\s \s		System.out.println("Starting C"); \\
			\s	\} \\
			\} 
		}
		\newpage
		\commandblock{
			\$ javac New.java  <- Creates C.class New.clas New.java  \\ 
			\$ java New \\ 
			Starting New \\ 
			\$ java C \\
			Starting C
		}
	\end{itemize}
	
	
	
	\noteblock{
		\begin{itemize}
			\item Whether class contains main() method or not, and whether main() method is declared according to requirement or not, \textbf{these things are won’t be checked by compiler}.
			\item At runtime, \textbf{JVM is responsible to check these things}.
			\item If JVM unable to find main() method, then will throw runtime exception!
		\end{itemize}
	}
	
\end{flushleft}
\newpage



